"""
:platform: Unix, Windows
:synopsis: This is the main module. Run this file to start the GUI.
:moduleauthor: Michael Eller <mbe9a@virginia.edu>
"""

from sampRateGUI import Ui_Dialog as samprateWindow
from scaleAxesGUI import Ui_Dialog as scaleaxesWindow
from portsGUI import Ui_Dialog as portsWindow
from plotGUI import Ui_Dialog as plotWindow
from windowFilterGUI import Ui_Dialog as windowfilterWindow
from PyQt5 import QtCore, QtGui, QtWidgets
from settings_interface import restore_defaults, read_port_configuration, b1, m1, b2, m2
import serial
import time
import gc

#: Member *_serial_port* is a global variable representing the serial connection to the ADC.
#: It will be opened when either enabling the LCD display or starting the plot.
_serial_port = serial.Serial(baudrate=9600, timeout=2)


class Ui_MainWindow(object):
    """
    The graphical structure of *Ui_MainWindow* was generated by QtDesigner. The window contains a settings menu,
    LCD display, and a button to launch a live plot.
    """

    def setupUi(self, MainWindow):
        """
        This function initializes the window by altering the *MainWindow* object passed (by reference) to it.

        :param MainWindow: this must be of type PyQt5.QtWidgets.QMainWindow
        """

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(400, 500)
        MainWindow.setWindowIcon(QtGui.QIcon('resources/uva.ico'))

        # set central widget
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        MainWindow.setCentralWidget(self.centralwidget)

        # make a grid layout
        # grid layouts allow the window to be resized easily
        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout.setObjectName("gridLayout")

        # the following spacer items organize the objects in the window nicely
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem, 1, 2, 1, 1)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem1, 3, 1, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem2, 3, 3, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem3, 4, 2, 1, 1)
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout.addItem(spacerItem4, 1, 1, 1, 1)
        spacerItem5 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout.addItem(spacerItem5, 2, 3, 1, 1)

        # make a label for the LCD display
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setObjectName("label")
        self.gridLayout.addWidget(self.label, 0, 3, 1, 1, QtCore.Qt.AlignRight)

        # make the button that launches the live plot
        self.plot_btn = QtWidgets.QPushButton(self.centralwidget)
        self.plot_btn.setObjectName("plot_btn")
        self.gridLayout.addWidget(self.plot_btn, 3, 2, 2, 2)
        # connect the button click event to the show_plot() function in this class
        self.plot_btn.clicked.connect(self.show_plot)

        # create the LCD display
        self.lcdNumber = QtWidgets.QLCDNumber(self.centralwidget)
        self.lcdNumber.setObjectName("lcdNumber")
        self.gridLayout.addWidget(self.lcdNumber, 1, 2, 2, 2)
        # set the colors
        palette = self.lcdNumber.palette()
        palette.setColor(palette.Background, QtGui.QColor(0, 0, 0))
        palette.setColor(palette.Dark, QtGui.QColor(0, 0, 0))
        self.lcdNumber.setPalette(palette)

        # create a checkbox to enable or disable the LCD display functionality
        # this serves as the trigger to open and close the serial connection to the ADC
        self.checkBoxEnable = QtWidgets.QCheckBox(self.centralwidget)
        self.checkBoxEnable.setObjectName("checkBoxEnable")
        self.gridLayout.addWidget(self.checkBoxEnable, 0, 2, 1, 1)
        # connect the checkbox click event to the toggle_timer() function in this class
        self.checkBoxEnable.stateChanged.connect(self.toggle_timer)

        # create the statusbar, which holds the menu items
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        # make the menubar
        # contains settings options and exit button
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 516, 26))
        self.menubar.setObjectName("menubar")
        self.menuMain_Menu = QtWidgets.QMenu(self.menubar)
        self.menuMain_Menu.setObjectName("menuMain_Menu")
        self.menuSettings = QtWidgets.QMenu(self.menuMain_Menu)
        self.menuSettings.setObjectName("menuSettings")
        MainWindow.setMenuBar(self.menubar)

        # create the Exit menu item
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit")
        self.actionExit.setStatusTip('Exit application')
        # connect the action to the quit function
        self.actionExit.triggered.connect(QtWidgets.qApp.quit)

        # create the Sample Rate submenu settings item
        self.actionSample_Rate = QtWidgets.QAction(MainWindow)
        self.actionSample_Rate.setObjectName("actionSample_Rate")
        self.actionSample_Rate.setStatusTip('Set the plotter\'s sample rate')
        # connect the action to the function open_settings_sample_rate()
        self.actionSample_Rate.triggered.connect(self.open_settings_sample_rate)

        # create the Scale Axes submenu settings item
        self.actionScale_Axes = QtWidgets.QAction(MainWindow)
        self.actionScale_Axes.setObjectName("actionScale_Axes")
        self.actionScale_Axes.setStatusTip('Set the plotter\'s x-axis and y-axis limits')
        # connect the action to the function open_settings_scale_axes()
        self.actionScale_Axes.triggered.connect(self.open_settings_scale_axes)

        # create the Port Connection submenu settings item
        self.actionPort_Connection = QtWidgets.QAction(MainWindow)
        self.actionPort_Connection.setObjectName("actionPort_Connection")
        self.actionPort_Connection.setStatusTip('Set the serial port connection for data acquisition')
        # connect the action to the function open_settings_port()
        self.actionPort_Connection.triggered.connect(self.open_settings_port)

        # create the Window Filter submenu settings item
        self.actionWindow_Filter = QtWidgets.QAction(MainWindow)
        self.actionWindow_Filter.setObjectName("actionWindow_Filter")
        self.actionWindow_Filter.setStatusTip('Set the number of samples to use in a moving average')
        # connect the action to the function open_settings_filter()
        self.actionWindow_Filter.triggered.connect(self.open_settings_filter)

        # create the Restore Defaults submenu settings item
        self.actionRestore_Defaults = QtWidgets.QAction(MainWindow)
        self.actionRestore_Defaults.setObjectName("actionWindow_Filter")
        self.actionRestore_Defaults.setStatusTip('Set the number of samples to use in a moving average')
        # connect the action to the function restore_defaults() from settings_interface
        self.actionRestore_Defaults.triggered.connect(restore_defaults)

        # add all these actions to the menu with separators for a clean look
        self.menuSettings.addAction(self.actionWindow_Filter)
        self.menuSettings.addAction(self.actionSample_Rate)
        self.menuSettings.addAction(self.actionScale_Axes)
        self.menuSettings.addAction(self.actionPort_Connection)
        self.menuSettings.addSeparator()
        self.menuSettings.addAction(self.actionRestore_Defaults)
        self.menuMain_Menu.addAction(self.menuSettings.menuAction())
        self.menuMain_Menu.addSeparator()
        self.menuMain_Menu.addAction(self.actionExit)
        self.menubar.addAction(self.menuMain_Menu.menuAction())

        # create a popup message that will alert the user when the serial port is not set
        # if the port is not set or set correctly, the program will crash
        self.msg = QtWidgets.QMessageBox()
        self.msg.setIcon(QtWidgets.QMessageBox.Warning)
        self.msg.setText("Serial Port Not Set!")
        self.msg.setInformativeText("Please use the menu to set the serial port connection before "
                                    "attempting to display the endpoint signal.")
        self.msg.setWindowTitle("Warning")
        self.msg.setWindowIcon(QtGui.QIcon('resources/gear.ico'))

        # Windows does not play well with Python threading or multiprocessing, so
        # using the built in QTimer object to trigger a function periodically is far easier.
        # This timer is used to update the LCD with the ADC value every 1s.
        self.timer = QtCore.QTimer(MainWindow)
        self.timer.setSingleShot(False)
        # connect the timer trigger to the function update_display()
        self.timer.timeout.connect(self.update_display)

        # this attribute describes whether or not the port has ben set
        self.port_set = False
        # check to see if the user has set a port
        self.check_port()

        # this function translates all the objects created here and sets all the text
        self.retranslateUi(MainWindow)

        # make sure we connect the *MainWindow*'s signals to their corresponding slots
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        """
        This function translates the GUI objects of this class to the passed *MainWindow* objcect,
        then sets the text of the various objects in the main window.

        :param MainWindow: this must be of type PyQt5.QtWidgets.QMainWindow
        """

        # rename the translate function for readability
        _translate = QtCore.QCoreApplication.translate

        # main window title
        MainWindow.setWindowTitle(_translate("MainWindow", "Oxford Endpoint Plotter"))

        # label above the LCD
        self.label.setText(_translate("MainWindow", "Endpoint Signal"))

        # plot button
        self.plot_btn.setText(_translate("MainWindow", "Plot"))
        font = self.plot_btn.font()
        font.setPointSize(20)
        self.plot_btn.setFont(font)

        # label for LCD check box
        self.checkBoxEnable.setText(_translate("MainWindow", "Enable"))

        # set menu text
        self.menuMain_Menu.setTitle(_translate("MainWindow", "Menu"))
        self.menuSettings.setTitle(_translate("MainWindow", "Settings"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))

        # settings submenu text
        self.actionSample_Rate.setText(_translate("MainWindow", "Sample Rate"))
        self.actionScale_Axes.setText(_translate("MainWindow", "Scale Axes"))
        self.actionWindow_Filter.setText(_translate("MainWindow", "Window Filter"))
        self.actionPort_Connection.setText(_translate("MainWindow", "Port Connection"))
        self.actionRestore_Defaults.setText(_translate("MainWindow", "Restore Defaults"))

    def check_port(self):
        """
        Checks to see if the user has set a port. If not, the user will not be able to start the live plot or LCD.
        """

        # get the port string from the saved settings
        # this will be a string
        self.port = read_port_configuration()

        # get _serial_port from global context
        global _serial_port

        # if the port settings is set
        if len(self.port.strip()) > 0:
            # open the port
            _serial_port.setPort(self.port)
            self.port_set = True
        else:
            # display the warning message
            self.port_set = False
            self.msg.exec_()

    def open_settings_filter(self):
        """
        This function spawns an instance of *windowFilterGUI.Ui_Dialog*. This is triggered by
        clicking Menu > Settings > Window Filter.
        """

        # set it up
        Dialog = QtWidgets.QDialog()
        ui = windowfilterWindow()
        ui.setupUi(Dialog)

        # disable the button, so users can't open more than one window of this type
        self.actionWindow_Filter.setEnabled(False)

        # run it
        Dialog.show()
        Dialog.exec_()

        # re-enable the button
        self.actionWindow_Filter.setEnabled(True)

        # free up some memory
        del ui, Dialog
        gc.collect()

    def open_settings_sample_rate(self):
        """
        This function spawns an instance of *sampRateGUI.Ui_Dialog*. This is triggered by
        clicking Menu > Settings > Sample Rate.
        """

        # set it up
        Dialog = QtWidgets.QDialog()
        ui = samprateWindow()
        ui.setupUi(Dialog)

        # disable the button, so users can't open more than one window of this type
        self.actionSample_Rate.setEnabled(False)

        # run it
        Dialog.show()
        Dialog.exec_()

        # re-enable the button
        self.actionSample_Rate.setEnabled(True)

        # free up some memory
        del ui, Dialog
        gc.collect()

    def open_settings_scale_axes(self):
        """
        This function spawns an instance of *scaleAxesGUI.Ui_Dialog*. This is triggered by
        clicking Menu > Settings > Scale Axes.
        """

        # set it up
        Dialog = QtWidgets.QDialog()
        ui = scaleaxesWindow()
        ui.setupUi(Dialog)

        # disable the button, so users can't open more than one window of this type
        self.actionScale_Axes.setEnabled(False)

        # run it
        Dialog.show()
        Dialog.exec_()

        # re-enable the button
        self.actionScale_Axes.setEnabled(True)

        # free up some memory
        del ui, Dialog
        gc.collect()

    def open_settings_port(self):
        """
        This function spawns an instance of *portsGUI.Ui_Dialog*. This is triggered by
        clicking Menu > Settings > Port Connection.
        """

        # set it up
        Dialog = QtWidgets.QDialog()
        ui = portsWindow()
        ui.setupUi(Dialog)

        # disable the button, so users can't open more than one window of this type
        self.actionPort_Connection.setEnabled(False)

        # run it
        Dialog.show()
        Dialog.exec_()

        # re-enable the button
        self.actionPort_Connection.setEnabled(True)

        # free up some memory
        del ui, Dialog
        gc.collect()

        # check if the user has set the port
        self.check_port()

    def show_plot(self):
        """
        This function spawns an instance of *plotGUI.Ui_Dialog*. It is triggered by
        the user clicking the large 'Plot' button.
        """

        # if the user has not set the port, do not start the plot and open the warning message
        if not self.port_set:
            self.msg.exec_()
            return

        # free up some memory if we can, this is probably redundant
        gc.collect()

        # set it up
        Dialog = QtWidgets.QDialog()
        ui = plotWindow()
        ui.setupUi(Dialog)

        # disable the settings buttons that aren't able to change during plotting.
        # also disable the plot button and check box because only one connection to the
        # serial port is allowed at any given time.
        # the program will crash if the user tries to open the port while it's already being used.
        self.plot_btn.setEnabled(False)
        self.checkBoxEnable.setEnabled(False)
        self.actionPort_Connection.setEnabled(False)
        self.actionSample_Rate.setEnabled(False)
        self.actionRestore_Defaults.setEnabled(False)

        # run it
        Dialog.show()
        Dialog.exec_()

        # re-enable the buttons
        self.plot_btn.setEnabled(True)
        self.checkBoxEnable.setEnabled(True)
        self.actionPort_Connection.setEnabled(True)
        self.actionSample_Rate.setEnabled(True)
        self.actionRestore_Defaults.setEnabled(True)

        # free up some memory - this is critical.
        # if this is not done and blitting is disabled (it is disabled by default),
        # you will notice a dramatic degradation in performance with successive calls to this function ->
        # i.e. successive creations of plotGUI.Ui_Dialog.
        del ui, Dialog
        gc.collect()

    def toggle_timer(self):
        """
        This function is triggered on every click of the check box. If the check box is enabled and
        the user has set the serial port, this function enables a timer that will update the LCD every 1s.
        """

        # get _serial_port from global context
        global _serial_port

        # check box is checked
        if self.checkBoxEnable.checkState():

            # if the user hasn't set the port, uncheck the check box and display the warning message
            if not self.port_set:
                self.msg.exec_()
                self.checkBoxEnable.click()
            else:
                # open the serial port and start the 1s timer
                # on a timer timeout, update_display() will execute
                _serial_port.open()
                time.sleep(2)
                self.timer.start(1000)

                # disable the buttons that open the serial port
                # the program can only have one open connection to the
                # serial port at all times
                self.plot_btn.setEnabled(False)
                self.actionPort_Connection.setEnabled(False)

        # if the check box is unchecked, close the serial port and stop the timer
        else:
            _serial_port.close()
            self.timer.stop()

            # re-enable the buttons
            self.plot_btn.setEnabled(True)
            self.actionPort_Connection.setEnabled(True)

    def update_display(self):
        """
        This function will execute on the 1s timer's timeout. It will then request the most recent ADC value
        from the serial port and display the corrected value on the LCD.
        """

        # get _serial_port from the global context
        global _serial_port

        # write 'a' to the serial port.
        # the embedded micro-controller is listening for an 'a' over the serial connection.
        # Once it receives an 'a', it will send the latest ADC value in response.
        # This was done to eliminate the need for a buffer.
        _serial_port.write(b'a')

        # read the value from the serial connection
        val = int(_serial_port.readline().decode('ascii').strip())

        # m1, b1, m2, b2 are the slopes and y-intercepts of a calibration curve split into two segments.
        # the calibration curve is more accurate if a slope is calculated at small values
        # separately from the large values.
        # These numbers correct for two things:
        #                   * the resistor ratio in the custom PCB
        #                   * turning the ADC value (0-1024) into an actual voltage
        # These values can be found in settings_interface module and are extracted from direct measurements.

        # if the value from the ADC is less than 150 (on a scale of 0-1024 that's equivalent to about 10V).
        if val < 150:
            val = (val - b1) / m1
        else:
            val = (val - b2) / m2

        # display the received and corrected value
        self.lcdNumber.display(val)


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
